<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>AngularJS Routing with Permissions | Konpat’s Record of Struggles</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="AngularJS Routing with Permissions" />
<meta name="author" content="Konpat Preechakul" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="ไม่ว่าจะเขียนเว็บด้วยเทคนิคอะไรก็ตาม สิ่งที่เราต้องทำก็ไม่พ้นระบบ Routing และยิ่งมากกว่านั้นคือจำกัดว่าใครสามารถเข้าไปชมหน้าไหนได้บ้าง (authorization) ปัญหานี้ไม่ใช่เรื่องใหญ่เลยเมื่อเราเขียนเว็บไซต์ที่จัดการเรื่องนี้จากทาง backend กล่าวคือหากเราใช้ PHP Framework เช่น Laravel เราก็สามารถจัดการเรื่องนี้ใน routes.php โดยอาจจะเขียน filter กำกับไว้ (ไม่ว่าจะเขียนไว้ที่ใดก็ตาม) ด้วยว่าใครสามารถเข้า route นี้ได้บ้าง ถ้าไม่ได้จะต้องทำอย่างไรต่อไป เราก็แค่เขียนฟังก์ชันกำกับไว้เท่านั้นเอง แต่เมื่อเราเสกสรรค์เว็บไซต์ด้วยเทคโนโลยีทาง frontend อย่าง AnuglarJS แล้วปัญหานี้มันนุ่มลึกกว่านั้นอยู่พอสมควร ระลึกไว้เสมอว่าเรามาใช้ AngularJS เพื่อต้องการการตอบสนองอย่างทันที ราบรื่น สวยงาม Basic approach ผมจัดการ routing ใน AngularJS ด้วย angular-ui-router ซึ่งก็เป็น pagkage ที่หลายคนแนะนำว่าดีมีความสามารถหลากหลายกว่าตัวหลักของ AngularJS เอง ผมอาจจะเร่ิมเขียน หน้า routes.coffee ดังนี้ angular.module &#39;routes&#39;, [] .config [ &#39;$stateProvider&#39; (stateProvider) -&gt; stateProvider .state &#39;user&#39;, { url: &#39;^/user&#39; templateUrl: &quot;public/user.html&quot; controller: &#39;userCtrl&#39; } ] ตอนนี้ผมได้กฎการ route โดยกำหนด state user ขึ้นมาโดยผูก state นี้กับ url /user (การเขียน ^ นำหน้าทำให้เป็น absolute url ไม่ขึ้นกับว่า state นี้เป็นรองจาก state ไหน) ผมอาจจะมีไฟล์ user.coffee ไว้เขียนรายละเอียดของ userCtrl ด้วย โดยผมอยากให้ userCtlr เป็น controller เกี่ยวกับหน้าส่วนตัวของ user แต่ละคนในระบบ ดังนั้นหน้านี้จะต้องเป็นหน้าที่เฉพาะคนที่ login แล้วเท่านั้นจึงเข้าได้ หากเค้ายังไม่ก็จะถูกเตะออกไปที่อื่นเช่นหน้าแรก โดยสมมติว่าผมมี userService ไว้สำหรับทำงานเช่น เช็คว่าผู้ใช้ login อยู่หรือเปล่า หรืองานอื่น ๆ angular.module &#39;user&#39;, [] .controller [ &#39;$scope&#39; &#39;$state&#39; &#39;userService&#39; ( s, state, userService) -&gt; if not userService.isLogin() # user has not logged in yet # redirect him to homepage state.go &#39;/&#39; else ... do something interesting here ... ] ถ้าผมไม่ได้เขียนผิดอะไร แค่นี้เราก็สามารถทำงานได้แล้ว เพราะว่าคนที่จะทำงานในส่วน else ได้ก็คือคนที่ login เรียบร้อยแล้วเท่านั้น แต่… จะเห็นในส่วนของ module routes ที่เราเขียนไว้ก่อนหน้า state แต่ละ state จะเรียกสองส่วนพร้อม ๆ กันคือส่วนของ template และส่วนของ controller แปลว่าหาก template ถูกวางลงไปที่หน้า browser ของผู้ใช้แล้วจึงมีการเรียก state.go() จะส่งผลให้เกิดการกระพริบของหน้าจอแน่นอนเหมือน เข้าไปได้ครึ่งตัวแล้วถูกเตะออกมา ไม่รู้ว่าคุณจะรู้สึกอย่างไร แต่ผมรู้สึกแย่… ผมจึงต้องหาวิธีแก้ปัญหานี้ The better one หากเราต้องการจะเช็คและไม่ต้องการให้เกิดการกระพริบแน่ ๆ เราต้องเช็คก่อนหน้านั้น อันที่จริงผมเลือก เช็คตั้งแต่เร่ิมมีการเปลี่ยน url เลย วิธีการนี้ทำได้ด้วยการ ฟัง message $stateChangeStart ที่ rootScope ซึ่ง angular-ui-router จะส่งมาเมื่อเร่ิมมีการเปลี่ยน state ดังนั้นหากเราจัดการตั้งแต่ตอนนี้ ก็จะยังไม่มีการโหลด template ใด ๆ ผมเขียนโค้ดส่วนนี้ไว้ที่ไฟล์หลัก สมมติเป็น app.coffee ในส่วน .run() แต่มันก็จะมีปัญหาตามมาอยู่ที่ว่าในเมื่อเราเขียนครอบไว้หมด เราจะรู้ได้อย่างไรว่าหน้าที่กำลังจะไปเนี่ย ใครเข้าได้บ้าง? ดังนั้นผมจึงต้องระบุข้อมูลบางอย่างเพิ่มเติมในแต่ละ route ว่า “ใครเข้าได้บ้าง?” ผมเห็นคนแก้ปัญหานี้ด้วยการเลียนแบบ mode ในระบบปฎิบัติการพวก unix และ unix-like เพิ่มไฟล์ constant.coffee angular.module &#39;constant&#39;, [] .constant &#39;USER_ROLES&#39;, all: parseInt &#39;111&#39;, 2 guest: parseInt &#39;001&#39;, 2 member: parseInt &#39;010&#39;, 2 admin: parseInt &#39;100&#39;, 2 ไฟล์นี้จะกำหนดว่า 001 คือ ใครก็เข้าได้ (guest) หรือ 010 คือ member เข้าได้ แต่ว่าถ้าเป็น 011 หรือ guest | member ก็แสดงว่าเข้าได้ทั้งคู่ แก้ routes.coffee เราต้องการให้หน้า user เข้าได้แค่ member (ในที่นี้ admin ก็อาจจะเข้าได้ แต่ว่าไม่ใช่ประเด็นอะไร) angular.module &#39;routes&#39;, [] .config [ &#39;$stateProvider&#39; (stateProvider) -&gt; stateProvider .state &#39;user&#39;, { url: &#39;^/user&#39; templateUrl: &quot;public/user.html&quot; controller: &#39;userCtrl&#39; data: { roles: [ { authorized: USER_ROLES.member | USER_ROLES.admin no: &#39;login&#39; yes: null } ] } } ] ตอนนี้เราเพิ่มข้อมูลเล็กน้อยคือส่วน data ซึ่งจะมี roles อยู่ด้านใน (ซึ่ง roles เป็น array) ผมตั้งใจเอาไว้ว่า authorized คือ รายการของผู้ที่เราสนใจ (ไม่ได้แปลว่าเราต้อนรับ) no ระบุว่าหาก ไม่ใช่คนเหล่านี้แล้วเราจะ เตะ เขาไปที่ไหน (ในที่นี้เราเตะคนที่ยังไม่ login ไป login) yes ระบุว่าหาก ใช่คนเหล่านี้แล้วเราจะ เตะ เขาไปที่ไหน ซึ่งผมตั้งไว้เป็น null แปลว่าไม่เตะ อันที่จริง yes กับ no ก็ไม่ควรมีค่าในเวลาเดียวกันไม่งั้นหน้านี้ก็ไม่น่าจะมีคนเข้าได้ เนื่องจาก roles เป็น array เราก็จะเช็คทีละสมาชิกของ roles หากเช็คแล้วไม่มีการ เตะ เกิดขึ้นก็จะไปเช็ค roles ตัวต่อไปเรื่อย ๆ จนกว่าจะครบ คนที่เข้าหน้านี้ได้ก็คือที่ไม่ถูกเตะเลย ที่เหลือก็แค่เขียนโค้ดเพื่อบังคับใช้กฎเหล่านี้ เขียนส่วนบังคับใช้กฎ ในหน้า app.coffee ปกติผมใช้ app.coffee เป็นหน้าเร่ิมต้นของ project ซึ่งก็จะมี injector ต่าง ๆ มากมายในหน้านี้ แต่ตอนนี้เราจะสนใจแค่ส่วน .run() เท่านั้น ซึ่งจะเป็นส่วนที่เราจะเขียนตัวฟัง event $stateChangeStart ผมสมมติว่ามี method userService.getRoles() ซึ่งจะบอกว่าผู้ใช้เป็นใคร เช่น 001 คือเป็นคนธรรมดา หรือ 010 เป็น member ที่ login แล้ว ผมจะพยายามเขียน comment ให้ละเอียดเพื่อจะได้อ่านแล้วเข้าใจได้ง่ายขึ้น angular.module &#39;app&#39;, [ ... many injectors ...] .run [ &#39;$rootScope&#39; &#39;userService&#39; &#39;USER_ROLES&#39; &#39;$state&#39; ( rootScope, userService, USER_ROLES, state ) -&gt; # this var is needed to determine whether we should check # for the user&#39;s role or not intendedState = null rootScope.$on &#39;$stateChangeStart&#39;, (event, next, current) -&gt; # the target route hasn&#39;t been specified its mode # so, anyone can get in if not next.data? or not next.data.roles? # update intendedState categories: dev intendedState = next.name return # the user is there! # because intendedState is where he&#39;s now going to # no permission checking this time (we&#39;ve checked him last time) if next.name is intendedState # update intendedState categories: dev intendedState = next.name return # since, authorization takes time! # stop the page from normal redirection # because, we have to authorize the user first event.preventDefault() # get the user&#39;s role # we use callback function since `getRole` is not always fast userService.getRole (myRole) -&gt; # get the target page&#39;s mode roles = next.data.roles redirection = {} # check user&#39;s role with each page&#39;s restriction for each in roles if (each.authorized &amp; myRole) isnt 0 # the user is authorized if each.yes? # follow the YES seciton, if exists redirection = target: each.yes break else # the user isn&#39;t authorized if each.no? # follow the NO section, if exists redirection = target: each.no break if not redirection.target? # the user is good, no need to kick him # redirect user to where he intended to go # according to &#39;next.name&#39; intendedState = next.name # attach &#39;current&#39; parameters to the redirection state.go next.name, current else # the user is not quailified, he has to be kicked somewhere # as described in &#39;redirection.target&#39; intendedState = redirection.target # attach &#39;current&#39; parameters to the redirection state.go redirection.target, current ] วิธีนี้ยังมีปัญหาอยู่ที่ต้องมีการ redirect ถึง 2 ครั้ง กว่าจะเข้าไปยังหน้าที่มีการกำหนด permission ไว้ได้ เพราะว่า redirect ครั้งแรกเราก็จะตรวจสอบสิทธิ์การเข้าหน้านั้นก่อนซึ่งอาจจะต้องใช้เวลา เนื่องจาก userService.getRoles() อาจจะไม่เร็วในบางกรณี เมื่อตรวจสอบเสร็จแล้วก็ต้อง redirect อีกครั้งเพื่อไปยังหน้าที่ต้องการจริง ๆ ปัญหาของตรงนี้อยู่ที่ว่า เราไม่มีทางทำให้ userService.getRoles() เร็วเสมอต้นเสมอปลายได้ (ต่อให้มีการ cache ผลลัพธ์ไว้) เพราะว่าในกรณีแย่ ๆ เราก็ต้องเรียก http request ไปยัง server อยู่ดี เมื่อเราเรียก event.preventDefault แล้วแต่ไม่มี method สำหรับ resumeDefault ทำให้ต่อให้เราเช็คแล้วว่า user คนนี้เข้าหน้านี้ได้ แต่ก็ไม่สามารถให้เค้าเข้าไปต่อได้ (เนื่องจากเราหยุดกระบวนการไปแล้ว) เราต้องเริ่มกระบวนการใหม่อีกครั้งอยู่ดี อย่างไรก็ดีนี่เป็นวิธีที่ผมใช้จริง ๆ และแก้ปัญหาการกระพริบได้จริง ๆ แต่ผมก็ยังหวังว่าจะมีวิธีที่ดีกว่านี้ที่จะไม่ต้อง redirect ถึง 2 ครั้ง และหากมีใครแนะนำผมก็ยินดียิ่ง :D" />
<meta property="og:description" content="ไม่ว่าจะเขียนเว็บด้วยเทคนิคอะไรก็ตาม สิ่งที่เราต้องทำก็ไม่พ้นระบบ Routing และยิ่งมากกว่านั้นคือจำกัดว่าใครสามารถเข้าไปชมหน้าไหนได้บ้าง (authorization) ปัญหานี้ไม่ใช่เรื่องใหญ่เลยเมื่อเราเขียนเว็บไซต์ที่จัดการเรื่องนี้จากทาง backend กล่าวคือหากเราใช้ PHP Framework เช่น Laravel เราก็สามารถจัดการเรื่องนี้ใน routes.php โดยอาจจะเขียน filter กำกับไว้ (ไม่ว่าจะเขียนไว้ที่ใดก็ตาม) ด้วยว่าใครสามารถเข้า route นี้ได้บ้าง ถ้าไม่ได้จะต้องทำอย่างไรต่อไป เราก็แค่เขียนฟังก์ชันกำกับไว้เท่านั้นเอง แต่เมื่อเราเสกสรรค์เว็บไซต์ด้วยเทคโนโลยีทาง frontend อย่าง AnuglarJS แล้วปัญหานี้มันนุ่มลึกกว่านั้นอยู่พอสมควร ระลึกไว้เสมอว่าเรามาใช้ AngularJS เพื่อต้องการการตอบสนองอย่างทันที ราบรื่น สวยงาม Basic approach ผมจัดการ routing ใน AngularJS ด้วย angular-ui-router ซึ่งก็เป็น pagkage ที่หลายคนแนะนำว่าดีมีความสามารถหลากหลายกว่าตัวหลักของ AngularJS เอง ผมอาจจะเร่ิมเขียน หน้า routes.coffee ดังนี้ angular.module &#39;routes&#39;, [] .config [ &#39;$stateProvider&#39; (stateProvider) -&gt; stateProvider .state &#39;user&#39;, { url: &#39;^/user&#39; templateUrl: &quot;public/user.html&quot; controller: &#39;userCtrl&#39; } ] ตอนนี้ผมได้กฎการ route โดยกำหนด state user ขึ้นมาโดยผูก state นี้กับ url /user (การเขียน ^ นำหน้าทำให้เป็น absolute url ไม่ขึ้นกับว่า state นี้เป็นรองจาก state ไหน) ผมอาจจะมีไฟล์ user.coffee ไว้เขียนรายละเอียดของ userCtrl ด้วย โดยผมอยากให้ userCtlr เป็น controller เกี่ยวกับหน้าส่วนตัวของ user แต่ละคนในระบบ ดังนั้นหน้านี้จะต้องเป็นหน้าที่เฉพาะคนที่ login แล้วเท่านั้นจึงเข้าได้ หากเค้ายังไม่ก็จะถูกเตะออกไปที่อื่นเช่นหน้าแรก โดยสมมติว่าผมมี userService ไว้สำหรับทำงานเช่น เช็คว่าผู้ใช้ login อยู่หรือเปล่า หรืองานอื่น ๆ angular.module &#39;user&#39;, [] .controller [ &#39;$scope&#39; &#39;$state&#39; &#39;userService&#39; ( s, state, userService) -&gt; if not userService.isLogin() # user has not logged in yet # redirect him to homepage state.go &#39;/&#39; else ... do something interesting here ... ] ถ้าผมไม่ได้เขียนผิดอะไร แค่นี้เราก็สามารถทำงานได้แล้ว เพราะว่าคนที่จะทำงานในส่วน else ได้ก็คือคนที่ login เรียบร้อยแล้วเท่านั้น แต่… จะเห็นในส่วนของ module routes ที่เราเขียนไว้ก่อนหน้า state แต่ละ state จะเรียกสองส่วนพร้อม ๆ กันคือส่วนของ template และส่วนของ controller แปลว่าหาก template ถูกวางลงไปที่หน้า browser ของผู้ใช้แล้วจึงมีการเรียก state.go() จะส่งผลให้เกิดการกระพริบของหน้าจอแน่นอนเหมือน เข้าไปได้ครึ่งตัวแล้วถูกเตะออกมา ไม่รู้ว่าคุณจะรู้สึกอย่างไร แต่ผมรู้สึกแย่… ผมจึงต้องหาวิธีแก้ปัญหานี้ The better one หากเราต้องการจะเช็คและไม่ต้องการให้เกิดการกระพริบแน่ ๆ เราต้องเช็คก่อนหน้านั้น อันที่จริงผมเลือก เช็คตั้งแต่เร่ิมมีการเปลี่ยน url เลย วิธีการนี้ทำได้ด้วยการ ฟัง message $stateChangeStart ที่ rootScope ซึ่ง angular-ui-router จะส่งมาเมื่อเร่ิมมีการเปลี่ยน state ดังนั้นหากเราจัดการตั้งแต่ตอนนี้ ก็จะยังไม่มีการโหลด template ใด ๆ ผมเขียนโค้ดส่วนนี้ไว้ที่ไฟล์หลัก สมมติเป็น app.coffee ในส่วน .run() แต่มันก็จะมีปัญหาตามมาอยู่ที่ว่าในเมื่อเราเขียนครอบไว้หมด เราจะรู้ได้อย่างไรว่าหน้าที่กำลังจะไปเนี่ย ใครเข้าได้บ้าง? ดังนั้นผมจึงต้องระบุข้อมูลบางอย่างเพิ่มเติมในแต่ละ route ว่า “ใครเข้าได้บ้าง?” ผมเห็นคนแก้ปัญหานี้ด้วยการเลียนแบบ mode ในระบบปฎิบัติการพวก unix และ unix-like เพิ่มไฟล์ constant.coffee angular.module &#39;constant&#39;, [] .constant &#39;USER_ROLES&#39;, all: parseInt &#39;111&#39;, 2 guest: parseInt &#39;001&#39;, 2 member: parseInt &#39;010&#39;, 2 admin: parseInt &#39;100&#39;, 2 ไฟล์นี้จะกำหนดว่า 001 คือ ใครก็เข้าได้ (guest) หรือ 010 คือ member เข้าได้ แต่ว่าถ้าเป็น 011 หรือ guest | member ก็แสดงว่าเข้าได้ทั้งคู่ แก้ routes.coffee เราต้องการให้หน้า user เข้าได้แค่ member (ในที่นี้ admin ก็อาจจะเข้าได้ แต่ว่าไม่ใช่ประเด็นอะไร) angular.module &#39;routes&#39;, [] .config [ &#39;$stateProvider&#39; (stateProvider) -&gt; stateProvider .state &#39;user&#39;, { url: &#39;^/user&#39; templateUrl: &quot;public/user.html&quot; controller: &#39;userCtrl&#39; data: { roles: [ { authorized: USER_ROLES.member | USER_ROLES.admin no: &#39;login&#39; yes: null } ] } } ] ตอนนี้เราเพิ่มข้อมูลเล็กน้อยคือส่วน data ซึ่งจะมี roles อยู่ด้านใน (ซึ่ง roles เป็น array) ผมตั้งใจเอาไว้ว่า authorized คือ รายการของผู้ที่เราสนใจ (ไม่ได้แปลว่าเราต้อนรับ) no ระบุว่าหาก ไม่ใช่คนเหล่านี้แล้วเราจะ เตะ เขาไปที่ไหน (ในที่นี้เราเตะคนที่ยังไม่ login ไป login) yes ระบุว่าหาก ใช่คนเหล่านี้แล้วเราจะ เตะ เขาไปที่ไหน ซึ่งผมตั้งไว้เป็น null แปลว่าไม่เตะ อันที่จริง yes กับ no ก็ไม่ควรมีค่าในเวลาเดียวกันไม่งั้นหน้านี้ก็ไม่น่าจะมีคนเข้าได้ เนื่องจาก roles เป็น array เราก็จะเช็คทีละสมาชิกของ roles หากเช็คแล้วไม่มีการ เตะ เกิดขึ้นก็จะไปเช็ค roles ตัวต่อไปเรื่อย ๆ จนกว่าจะครบ คนที่เข้าหน้านี้ได้ก็คือที่ไม่ถูกเตะเลย ที่เหลือก็แค่เขียนโค้ดเพื่อบังคับใช้กฎเหล่านี้ เขียนส่วนบังคับใช้กฎ ในหน้า app.coffee ปกติผมใช้ app.coffee เป็นหน้าเร่ิมต้นของ project ซึ่งก็จะมี injector ต่าง ๆ มากมายในหน้านี้ แต่ตอนนี้เราจะสนใจแค่ส่วน .run() เท่านั้น ซึ่งจะเป็นส่วนที่เราจะเขียนตัวฟัง event $stateChangeStart ผมสมมติว่ามี method userService.getRoles() ซึ่งจะบอกว่าผู้ใช้เป็นใคร เช่น 001 คือเป็นคนธรรมดา หรือ 010 เป็น member ที่ login แล้ว ผมจะพยายามเขียน comment ให้ละเอียดเพื่อจะได้อ่านแล้วเข้าใจได้ง่ายขึ้น angular.module &#39;app&#39;, [ ... many injectors ...] .run [ &#39;$rootScope&#39; &#39;userService&#39; &#39;USER_ROLES&#39; &#39;$state&#39; ( rootScope, userService, USER_ROLES, state ) -&gt; # this var is needed to determine whether we should check # for the user&#39;s role or not intendedState = null rootScope.$on &#39;$stateChangeStart&#39;, (event, next, current) -&gt; # the target route hasn&#39;t been specified its mode # so, anyone can get in if not next.data? or not next.data.roles? # update intendedState categories: dev intendedState = next.name return # the user is there! # because intendedState is where he&#39;s now going to # no permission checking this time (we&#39;ve checked him last time) if next.name is intendedState # update intendedState categories: dev intendedState = next.name return # since, authorization takes time! # stop the page from normal redirection # because, we have to authorize the user first event.preventDefault() # get the user&#39;s role # we use callback function since `getRole` is not always fast userService.getRole (myRole) -&gt; # get the target page&#39;s mode roles = next.data.roles redirection = {} # check user&#39;s role with each page&#39;s restriction for each in roles if (each.authorized &amp; myRole) isnt 0 # the user is authorized if each.yes? # follow the YES seciton, if exists redirection = target: each.yes break else # the user isn&#39;t authorized if each.no? # follow the NO section, if exists redirection = target: each.no break if not redirection.target? # the user is good, no need to kick him # redirect user to where he intended to go # according to &#39;next.name&#39; intendedState = next.name # attach &#39;current&#39; parameters to the redirection state.go next.name, current else # the user is not quailified, he has to be kicked somewhere # as described in &#39;redirection.target&#39; intendedState = redirection.target # attach &#39;current&#39; parameters to the redirection state.go redirection.target, current ] วิธีนี้ยังมีปัญหาอยู่ที่ต้องมีการ redirect ถึง 2 ครั้ง กว่าจะเข้าไปยังหน้าที่มีการกำหนด permission ไว้ได้ เพราะว่า redirect ครั้งแรกเราก็จะตรวจสอบสิทธิ์การเข้าหน้านั้นก่อนซึ่งอาจจะต้องใช้เวลา เนื่องจาก userService.getRoles() อาจจะไม่เร็วในบางกรณี เมื่อตรวจสอบเสร็จแล้วก็ต้อง redirect อีกครั้งเพื่อไปยังหน้าที่ต้องการจริง ๆ ปัญหาของตรงนี้อยู่ที่ว่า เราไม่มีทางทำให้ userService.getRoles() เร็วเสมอต้นเสมอปลายได้ (ต่อให้มีการ cache ผลลัพธ์ไว้) เพราะว่าในกรณีแย่ ๆ เราก็ต้องเรียก http request ไปยัง server อยู่ดี เมื่อเราเรียก event.preventDefault แล้วแต่ไม่มี method สำหรับ resumeDefault ทำให้ต่อให้เราเช็คแล้วว่า user คนนี้เข้าหน้านี้ได้ แต่ก็ไม่สามารถให้เค้าเข้าไปต่อได้ (เนื่องจากเราหยุดกระบวนการไปแล้ว) เราต้องเริ่มกระบวนการใหม่อีกครั้งอยู่ดี อย่างไรก็ดีนี่เป็นวิธีที่ผมใช้จริง ๆ และแก้ปัญหาการกระพริบได้จริง ๆ แต่ผมก็ยังหวังว่าจะมีวิธีที่ดีกว่านี้ที่จะไม่ต้อง redirect ถึง 2 ครั้ง และหากมีใครแนะนำผมก็ยินดียิ่ง :D" />
<link rel="canonical" href="https://blog.konpat.me/dev/2015/05/28/angularjs-routing-with-permissions-2.html" />
<meta property="og:url" content="https://blog.konpat.me/dev/2015/05/28/angularjs-routing-with-permissions-2.html" />
<meta property="og:site_name" content="Konpat’s Record of Struggles" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-05-28T11:18:00+07:00" />
<script type="application/ld+json">
{"description":"ไม่ว่าจะเขียนเว็บด้วยเทคนิคอะไรก็ตาม สิ่งที่เราต้องทำก็ไม่พ้นระบบ Routing และยิ่งมากกว่านั้นคือจำกัดว่าใครสามารถเข้าไปชมหน้าไหนได้บ้าง (authorization) ปัญหานี้ไม่ใช่เรื่องใหญ่เลยเมื่อเราเขียนเว็บไซต์ที่จัดการเรื่องนี้จากทาง backend กล่าวคือหากเราใช้ PHP Framework เช่น Laravel เราก็สามารถจัดการเรื่องนี้ใน routes.php โดยอาจจะเขียน filter กำกับไว้ (ไม่ว่าจะเขียนไว้ที่ใดก็ตาม) ด้วยว่าใครสามารถเข้า route นี้ได้บ้าง ถ้าไม่ได้จะต้องทำอย่างไรต่อไป เราก็แค่เขียนฟังก์ชันกำกับไว้เท่านั้นเอง แต่เมื่อเราเสกสรรค์เว็บไซต์ด้วยเทคโนโลยีทาง frontend อย่าง AnuglarJS แล้วปัญหานี้มันนุ่มลึกกว่านั้นอยู่พอสมควร ระลึกไว้เสมอว่าเรามาใช้ AngularJS เพื่อต้องการการตอบสนองอย่างทันที ราบรื่น สวยงาม Basic approach ผมจัดการ routing ใน AngularJS ด้วย angular-ui-router ซึ่งก็เป็น pagkage ที่หลายคนแนะนำว่าดีมีความสามารถหลากหลายกว่าตัวหลักของ AngularJS เอง ผมอาจจะเร่ิมเขียน หน้า routes.coffee ดังนี้ angular.module &#39;routes&#39;, [] .config [ &#39;$stateProvider&#39; (stateProvider) -&gt; stateProvider .state &#39;user&#39;, { url: &#39;^/user&#39; templateUrl: &quot;public/user.html&quot; controller: &#39;userCtrl&#39; } ] ตอนนี้ผมได้กฎการ route โดยกำหนด state user ขึ้นมาโดยผูก state นี้กับ url /user (การเขียน ^ นำหน้าทำให้เป็น absolute url ไม่ขึ้นกับว่า state นี้เป็นรองจาก state ไหน) ผมอาจจะมีไฟล์ user.coffee ไว้เขียนรายละเอียดของ userCtrl ด้วย โดยผมอยากให้ userCtlr เป็น controller เกี่ยวกับหน้าส่วนตัวของ user แต่ละคนในระบบ ดังนั้นหน้านี้จะต้องเป็นหน้าที่เฉพาะคนที่ login แล้วเท่านั้นจึงเข้าได้ หากเค้ายังไม่ก็จะถูกเตะออกไปที่อื่นเช่นหน้าแรก โดยสมมติว่าผมมี userService ไว้สำหรับทำงานเช่น เช็คว่าผู้ใช้ login อยู่หรือเปล่า หรืองานอื่น ๆ angular.module &#39;user&#39;, [] .controller [ &#39;$scope&#39; &#39;$state&#39; &#39;userService&#39; ( s, state, userService) -&gt; if not userService.isLogin() # user has not logged in yet # redirect him to homepage state.go &#39;/&#39; else ... do something interesting here ... ] ถ้าผมไม่ได้เขียนผิดอะไร แค่นี้เราก็สามารถทำงานได้แล้ว เพราะว่าคนที่จะทำงานในส่วน else ได้ก็คือคนที่ login เรียบร้อยแล้วเท่านั้น แต่… จะเห็นในส่วนของ module routes ที่เราเขียนไว้ก่อนหน้า state แต่ละ state จะเรียกสองส่วนพร้อม ๆ กันคือส่วนของ template และส่วนของ controller แปลว่าหาก template ถูกวางลงไปที่หน้า browser ของผู้ใช้แล้วจึงมีการเรียก state.go() จะส่งผลให้เกิดการกระพริบของหน้าจอแน่นอนเหมือน เข้าไปได้ครึ่งตัวแล้วถูกเตะออกมา ไม่รู้ว่าคุณจะรู้สึกอย่างไร แต่ผมรู้สึกแย่… ผมจึงต้องหาวิธีแก้ปัญหานี้ The better one หากเราต้องการจะเช็คและไม่ต้องการให้เกิดการกระพริบแน่ ๆ เราต้องเช็คก่อนหน้านั้น อันที่จริงผมเลือก เช็คตั้งแต่เร่ิมมีการเปลี่ยน url เลย วิธีการนี้ทำได้ด้วยการ ฟัง message $stateChangeStart ที่ rootScope ซึ่ง angular-ui-router จะส่งมาเมื่อเร่ิมมีการเปลี่ยน state ดังนั้นหากเราจัดการตั้งแต่ตอนนี้ ก็จะยังไม่มีการโหลด template ใด ๆ ผมเขียนโค้ดส่วนนี้ไว้ที่ไฟล์หลัก สมมติเป็น app.coffee ในส่วน .run() แต่มันก็จะมีปัญหาตามมาอยู่ที่ว่าในเมื่อเราเขียนครอบไว้หมด เราจะรู้ได้อย่างไรว่าหน้าที่กำลังจะไปเนี่ย ใครเข้าได้บ้าง? ดังนั้นผมจึงต้องระบุข้อมูลบางอย่างเพิ่มเติมในแต่ละ route ว่า “ใครเข้าได้บ้าง?” ผมเห็นคนแก้ปัญหานี้ด้วยการเลียนแบบ mode ในระบบปฎิบัติการพวก unix และ unix-like เพิ่มไฟล์ constant.coffee angular.module &#39;constant&#39;, [] .constant &#39;USER_ROLES&#39;, all: parseInt &#39;111&#39;, 2 guest: parseInt &#39;001&#39;, 2 member: parseInt &#39;010&#39;, 2 admin: parseInt &#39;100&#39;, 2 ไฟล์นี้จะกำหนดว่า 001 คือ ใครก็เข้าได้ (guest) หรือ 010 คือ member เข้าได้ แต่ว่าถ้าเป็น 011 หรือ guest | member ก็แสดงว่าเข้าได้ทั้งคู่ แก้ routes.coffee เราต้องการให้หน้า user เข้าได้แค่ member (ในที่นี้ admin ก็อาจจะเข้าได้ แต่ว่าไม่ใช่ประเด็นอะไร) angular.module &#39;routes&#39;, [] .config [ &#39;$stateProvider&#39; (stateProvider) -&gt; stateProvider .state &#39;user&#39;, { url: &#39;^/user&#39; templateUrl: &quot;public/user.html&quot; controller: &#39;userCtrl&#39; data: { roles: [ { authorized: USER_ROLES.member | USER_ROLES.admin no: &#39;login&#39; yes: null } ] } } ] ตอนนี้เราเพิ่มข้อมูลเล็กน้อยคือส่วน data ซึ่งจะมี roles อยู่ด้านใน (ซึ่ง roles เป็น array) ผมตั้งใจเอาไว้ว่า authorized คือ รายการของผู้ที่เราสนใจ (ไม่ได้แปลว่าเราต้อนรับ) no ระบุว่าหาก ไม่ใช่คนเหล่านี้แล้วเราจะ เตะ เขาไปที่ไหน (ในที่นี้เราเตะคนที่ยังไม่ login ไป login) yes ระบุว่าหาก ใช่คนเหล่านี้แล้วเราจะ เตะ เขาไปที่ไหน ซึ่งผมตั้งไว้เป็น null แปลว่าไม่เตะ อันที่จริง yes กับ no ก็ไม่ควรมีค่าในเวลาเดียวกันไม่งั้นหน้านี้ก็ไม่น่าจะมีคนเข้าได้ เนื่องจาก roles เป็น array เราก็จะเช็คทีละสมาชิกของ roles หากเช็คแล้วไม่มีการ เตะ เกิดขึ้นก็จะไปเช็ค roles ตัวต่อไปเรื่อย ๆ จนกว่าจะครบ คนที่เข้าหน้านี้ได้ก็คือที่ไม่ถูกเตะเลย ที่เหลือก็แค่เขียนโค้ดเพื่อบังคับใช้กฎเหล่านี้ เขียนส่วนบังคับใช้กฎ ในหน้า app.coffee ปกติผมใช้ app.coffee เป็นหน้าเร่ิมต้นของ project ซึ่งก็จะมี injector ต่าง ๆ มากมายในหน้านี้ แต่ตอนนี้เราจะสนใจแค่ส่วน .run() เท่านั้น ซึ่งจะเป็นส่วนที่เราจะเขียนตัวฟัง event $stateChangeStart ผมสมมติว่ามี method userService.getRoles() ซึ่งจะบอกว่าผู้ใช้เป็นใคร เช่น 001 คือเป็นคนธรรมดา หรือ 010 เป็น member ที่ login แล้ว ผมจะพยายามเขียน comment ให้ละเอียดเพื่อจะได้อ่านแล้วเข้าใจได้ง่ายขึ้น angular.module &#39;app&#39;, [ ... many injectors ...] .run [ &#39;$rootScope&#39; &#39;userService&#39; &#39;USER_ROLES&#39; &#39;$state&#39; ( rootScope, userService, USER_ROLES, state ) -&gt; # this var is needed to determine whether we should check # for the user&#39;s role or not intendedState = null rootScope.$on &#39;$stateChangeStart&#39;, (event, next, current) -&gt; # the target route hasn&#39;t been specified its mode # so, anyone can get in if not next.data? or not next.data.roles? # update intendedState categories: dev intendedState = next.name return # the user is there! # because intendedState is where he&#39;s now going to # no permission checking this time (we&#39;ve checked him last time) if next.name is intendedState # update intendedState categories: dev intendedState = next.name return # since, authorization takes time! # stop the page from normal redirection # because, we have to authorize the user first event.preventDefault() # get the user&#39;s role # we use callback function since `getRole` is not always fast userService.getRole (myRole) -&gt; # get the target page&#39;s mode roles = next.data.roles redirection = {} # check user&#39;s role with each page&#39;s restriction for each in roles if (each.authorized &amp; myRole) isnt 0 # the user is authorized if each.yes? # follow the YES seciton, if exists redirection = target: each.yes break else # the user isn&#39;t authorized if each.no? # follow the NO section, if exists redirection = target: each.no break if not redirection.target? # the user is good, no need to kick him # redirect user to where he intended to go # according to &#39;next.name&#39; intendedState = next.name # attach &#39;current&#39; parameters to the redirection state.go next.name, current else # the user is not quailified, he has to be kicked somewhere # as described in &#39;redirection.target&#39; intendedState = redirection.target # attach &#39;current&#39; parameters to the redirection state.go redirection.target, current ] วิธีนี้ยังมีปัญหาอยู่ที่ต้องมีการ redirect ถึง 2 ครั้ง กว่าจะเข้าไปยังหน้าที่มีการกำหนด permission ไว้ได้ เพราะว่า redirect ครั้งแรกเราก็จะตรวจสอบสิทธิ์การเข้าหน้านั้นก่อนซึ่งอาจจะต้องใช้เวลา เนื่องจาก userService.getRoles() อาจจะไม่เร็วในบางกรณี เมื่อตรวจสอบเสร็จแล้วก็ต้อง redirect อีกครั้งเพื่อไปยังหน้าที่ต้องการจริง ๆ ปัญหาของตรงนี้อยู่ที่ว่า เราไม่มีทางทำให้ userService.getRoles() เร็วเสมอต้นเสมอปลายได้ (ต่อให้มีการ cache ผลลัพธ์ไว้) เพราะว่าในกรณีแย่ ๆ เราก็ต้องเรียก http request ไปยัง server อยู่ดี เมื่อเราเรียก event.preventDefault แล้วแต่ไม่มี method สำหรับ resumeDefault ทำให้ต่อให้เราเช็คแล้วว่า user คนนี้เข้าหน้านี้ได้ แต่ก็ไม่สามารถให้เค้าเข้าไปต่อได้ (เนื่องจากเราหยุดกระบวนการไปแล้ว) เราต้องเริ่มกระบวนการใหม่อีกครั้งอยู่ดี อย่างไรก็ดีนี่เป็นวิธีที่ผมใช้จริง ๆ และแก้ปัญหาการกระพริบได้จริง ๆ แต่ผมก็ยังหวังว่าจะมีวิธีที่ดีกว่านี้ที่จะไม่ต้อง redirect ถึง 2 ครั้ง และหากมีใครแนะนำผมก็ยินดียิ่ง :D","author":{"@type":"Person","name":"Konpat Preechakul"},"@type":"BlogPosting","url":"https://blog.konpat.me/dev/2015/05/28/angularjs-routing-with-permissions-2.html","headline":"AngularJS Routing with Permissions","dateModified":"2015-05-28T11:18:00+07:00","datePublished":"2015-05-28T11:18:00+07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.konpat.me/dev/2015/05/28/angularjs-routing-with-permissions-2.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://blog.konpat.me/feed.xml" title="Konpat's Record of Struggles" /><script async src="https://www.googletagmanager.com/gtag/js?id=UA-91416417-1"></script>
<script>
  window['ga-disable-UA-91416417-1'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-91416417-1');
</script>
<script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        TeX: {
          equationNumbers: {
            autoNumber: "all"
          },
          extensions: ["cancel.js"]
        },
      })
  </script>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML' async></script>

</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Konpat&#39;s Record of Struggles</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>
        
        <div class="trigger">
          <!--
            my_page.autogen is populated by the pagination logic for all pages
                            that are automatically created by the gem. Check for non-existence to exclude pagination pages from site.pages iterators
          -->
          
            
          
            
            <a class="page-link" href="/about/">About</a>
            
          
            
          
            
            <a class="page-link" href="/tags/">Tags</a>
            
          
            
          
            
          
            
            <a class="page-link" href="/academic/index.html">Academic</a>
            
          
            
            <a class="page-link" href="/all/index.html">All</a>
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
            <a class="page-link" href="/dev/index.html">Dev</a>
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
        </div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">AngularJS Routing with Permissions</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2015-05-28T11:18:00+07:00" itemprop="datePublished">May 28, 2015
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>ไม่ว่าจะเขียนเว็บด้วยเทคนิคอะไรก็ตาม สิ่งที่เราต้องทำก็ไม่พ้นระบบ Routing และยิ่งมากกว่านั้นคือจำกัดว่าใครสามารถเข้าไปชมหน้าไหนได้บ้าง (authorization)</p>

<p>ปัญหานี้ไม่ใช่เรื่องใหญ่เลยเมื่อเราเขียนเว็บไซต์ที่จัดการเรื่องนี้จากทาง backend กล่าวคือหากเราใช้ PHP Framework เช่น Laravel เราก็สามารถจัดการเรื่องนี้ใน <em>routes.php</em> โดยอาจจะเขียน <em>filter</em> กำกับไว้ (ไม่ว่าจะเขียนไว้ที่ใดก็ตาม) ด้วยว่าใครสามารถเข้า route นี้ได้บ้าง ถ้าไม่ได้จะต้องทำอย่างไรต่อไป เราก็แค่เขียนฟังก์ชันกำกับไว้เท่านั้นเอง</p>

<p>แต่เมื่อเราเสกสรรค์เว็บไซต์ด้วยเทคโนโลยีทาง frontend อย่าง AnuglarJS แล้วปัญหานี้มันนุ่มลึกกว่านั้นอยู่พอสมควร <strong>ระลึกไว้เสมอว่าเรามาใช้ AngularJS เพื่อต้องการการตอบสนองอย่างทันที ราบรื่น สวยงาม</strong></p>

<h3 id="basic-approach">Basic approach</h3>
<p>ผมจัดการ routing ใน AngularJS ด้วย angular-ui-router ซึ่งก็เป็น pagkage ที่หลายคนแนะนำว่าดีมีความสามารถหลากหลายกว่าตัวหลักของ AngularJS เอง ผมอาจจะเร่ิมเขียน หน้า <em>routes.coffee</em> ดังนี้</p>

<div class="language-coffeescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">angular</span><span class="p">.</span><span class="na">module</span> <span class="s">'routes'</span><span class="p">,</span> <span class="p">[]</span>
<span class="p">.</span><span class="na">config</span> <span class="p">[</span>
  <span class="s">'$stateProvider'</span>
  <span class="p">(</span><span class="nx">stateProvider</span><span class="p">)</span> <span class="o">-&gt;</span>
  
    <span class="nx">stateProvider</span>
    <span class="p">.</span><span class="na">state</span> <span class="s">'user'</span><span class="p">,</span> <span class="p">{</span>
      <span class="na">url</span><span class="o">:</span> <span class="s">'^/user'</span>
      <span class="na">templateUrl</span><span class="o">:</span> <span class="s">"public/user.html"</span>
      <span class="na">controller</span><span class="o">:</span> <span class="s">'userCtrl'</span>
    <span class="p">}</span>
<span class="p">]</span>
</code></pre></div></div>
<p>ตอนนี้ผมได้กฎการ route โดยกำหนด state <em>user</em> ขึ้นมาโดยผูก state นี้กับ url <em>/user</em> (การเขียน ^ นำหน้าทำให้เป็น absolute url ไม่ขึ้นกับว่า state นี้เป็นรองจาก state ไหน)</p>

<p>ผมอาจจะมีไฟล์ <em>user.coffee</em> ไว้เขียนรายละเอียดของ <em>userCtrl</em> ด้วย โดยผมอยากให้ <em>userCtlr</em> เป็น controller เกี่ยวกับหน้าส่วนตัวของ user แต่ละคนในระบบ ดังนั้นหน้านี้จะต้องเป็นหน้าที่เฉพาะคนที่ login แล้วเท่านั้นจึงเข้าได้ หากเค้ายังไม่ก็จะถูกเตะออกไปที่อื่นเช่นหน้าแรก</p>

<p>โดยสมมติว่าผมมี userService ไว้สำหรับทำงานเช่น เช็คว่าผู้ใช้ login อยู่หรือเปล่า หรืองานอื่น ๆ</p>

<div class="language-coffeescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">angular</span><span class="p">.</span><span class="na">module</span> <span class="s">'user'</span><span class="p">,</span> <span class="p">[]</span>
<span class="p">.</span><span class="na">controller</span> <span class="p">[</span>
  <span class="s">'$scope'</span>
  <span class="s">'$state'</span>
  <span class="s">'userService'</span>
  <span class="p">(</span> <span class="nx">s</span><span class="p">,</span>
    <span class="nx">state</span><span class="p">,</span>
    <span class="nx">userService</span><span class="p">)</span> <span class="o">-&gt;</span>

    <span class="k">if</span> <span class="o">not</span> <span class="nx">userService</span><span class="p">.</span><span class="na">isLogin</span><span class="p">()</span>
      <span class="c1"># user has not logged in yet</span>
      <span class="c1"># redirect him to homepage</span>
      <span class="nx">state</span><span class="p">.</span><span class="na">go</span> <span class="s">'/'</span>
    <span class="k">else</span>
      <span class="p">...</span> <span class="na">do</span> <span class="nx">something</span> <span class="nx">interesting</span> <span class="nx">here</span> <span class="p">...</span>
<span class="p">]</span>

</code></pre></div></div>

<p>ถ้าผมไม่ได้เขียนผิดอะไร แค่นี้เราก็สามารถทำงานได้แล้ว เพราะว่าคนที่จะทำงานในส่วน else ได้ก็คือคนที่ login เรียบร้อยแล้วเท่านั้น</p>

<p><strong>แต่…</strong> จะเห็นในส่วนของ module <em>routes</em> ที่เราเขียนไว้ก่อนหน้า state แต่ละ state จะเรียกสองส่วนพร้อม ๆ กันคือส่วนของ template และส่วนของ controller แปลว่าหาก template ถูกวางลงไปที่หน้า browser ของผู้ใช้แล้วจึงมีการเรียก <em>state.go()</em> จะส่งผลให้เกิดการกระพริบของหน้าจอแน่นอนเหมือน <strong>เข้าไปได้ครึ่งตัวแล้วถูกเตะออกมา</strong> ไม่รู้ว่าคุณจะรู้สึกอย่างไร แต่ผมรู้สึกแย่… ผมจึงต้องหาวิธีแก้ปัญหานี้</p>

<h3 id="the-better-one">The better one</h3>
<p>หากเราต้องการจะเช็คและไม่ต้องการให้เกิดการกระพริบแน่ ๆ เราต้องเช็คก่อนหน้านั้น อันที่จริงผมเลือก <strong>เช็คตั้งแต่เร่ิมมีการเปลี่ยน url เลย</strong> วิธีการนี้ทำได้ด้วยการ ฟัง message <em>$stateChangeStart</em> ที่ <em>rootScope</em> ซึ่ง angular-ui-router จะส่งมาเมื่อ<strong>เร่ิม</strong>มีการเปลี่ยน state ดังนั้นหากเราจัดการตั้งแต่ตอนนี้ ก็จะยังไม่มีการโหลด template ใด ๆ</p>

<p>ผมเขียนโค้ดส่วนนี้ไว้ที่ไฟล์หลัก สมมติเป็น <em>app.coffee</em> ในส่วน <em>.run()</em> แต่มันก็จะมีปัญหาตามมาอยู่ที่ว่าในเมื่อเราเขียนครอบไว้หมด เราจะรู้ได้อย่างไรว่าหน้าที่กำลังจะไปเนี่ย <strong>ใครเข้าได้บ้าง?</strong></p>

<p>ดังนั้นผมจึงต้องระบุข้อมูลบางอย่างเพิ่มเติมในแต่ละ route ว่า “ใครเข้าได้บ้าง?” ผมเห็นคนแก้ปัญหานี้ด้วยการเลียนแบบ mode ในระบบปฎิบัติการพวก unix และ unix-like</p>

<h4 id="เพิ่มไฟล์-constantcoffee">เพิ่มไฟล์ constant.coffee</h4>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">angular</span><span class="p">.</span><span class="nx">module</span> <span class="s1">'constant'</span><span class="p">,</span> <span class="p">[]</span>

<span class="p">.</span><span class="nx">constant</span> <span class="s1">'USER_ROLES'</span><span class="p">,</span>
  <span class="nx">all</span><span class="p">:</span> <span class="nb">parseInt</span> <span class="s1">'111'</span><span class="p">,</span> <span class="mi">2</span>
  <span class="nx">guest</span><span class="p">:</span> <span class="nb">parseInt</span> <span class="s1">'001'</span><span class="p">,</span> <span class="mi">2</span>
  <span class="nx">member</span><span class="p">:</span> <span class="nb">parseInt</span> <span class="s1">'010'</span><span class="p">,</span> <span class="mi">2</span>
  <span class="nx">admin</span><span class="p">:</span> <span class="nb">parseInt</span> <span class="s1">'100'</span><span class="p">,</span> <span class="mi">2</span>

</code></pre></div></div>
<p>ไฟล์นี้จะกำหนดว่า 001 คือ ใครก็เข้าได้ (guest) หรือ 010 คือ member เข้าได้ แต่ว่าถ้าเป็น 011 หรือ guest | member ก็แสดงว่าเข้าได้ทั้งคู่</p>

<h4 id="แก้-routescoffee">แก้ routes.coffee</h4>
<p>เราต้องการให้หน้า user เข้าได้แค่ member (ในที่นี้ admin ก็อาจจะเข้าได้ แต่ว่าไม่ใช่ประเด็นอะไร)</p>

<div class="language-coffeescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">angular</span><span class="p">.</span><span class="na">module</span> <span class="s">'routes'</span><span class="p">,</span> <span class="p">[]</span>
<span class="p">.</span><span class="na">config</span> <span class="p">[</span>
  <span class="s">'$stateProvider'</span>
  <span class="p">(</span><span class="nx">stateProvider</span><span class="p">)</span> <span class="o">-&gt;</span>
  
    <span class="nx">stateProvider</span>
    <span class="p">.</span><span class="na">state</span> <span class="s">'user'</span><span class="p">,</span> <span class="p">{</span>
      <span class="na">url</span><span class="o">:</span> <span class="s">'^/user'</span>
      <span class="na">templateUrl</span><span class="o">:</span> <span class="s">"public/user.html"</span>
      <span class="na">controller</span><span class="o">:</span> <span class="s">'userCtrl'</span>

      <span class="na">data</span><span class="o">:</span> <span class="p">{</span>
        <span class="na">roles</span><span class="o">:</span> <span class="p">[</span>
        <span class="p">{</span> <span class="na">authorized</span><span class="o">:</span> <span class="nx">USER_ROLES</span><span class="p">.</span><span class="na">member</span> <span class="o">|</span> <span class="nx">USER_ROLES</span><span class="p">.</span><span class="na">admin</span>
          <span class="na">no</span><span class="o">:</span> <span class="s">'login'</span>
          <span class="na">yes</span><span class="o">:</span> <span class="no">null</span> <span class="p">}</span>
        <span class="p">]</span>
      <span class="p">}</span>
    <span class="p">}</span>
<span class="p">]</span>
</code></pre></div></div>
<p>ตอนนี้เราเพิ่มข้อมูลเล็กน้อยคือส่วน data ซึ่งจะมี roles อยู่ด้านใน (ซึ่ง roles เป็น array) ผมตั้งใจเอาไว้ว่า</p>
<ol>
  <li><strong>authorized</strong> คือ รายการของผู้ที่เราสนใจ (ไม่ได้แปลว่าเราต้อนรับ)</li>
  <li><strong>no</strong> ระบุว่าหาก ไม่ใช่คนเหล่านี้แล้วเราจะ <strong>เตะ</strong> เขาไปที่ไหน (ในที่นี้เราเตะคนที่ยังไม่ login ไป login)</li>
  <li><strong>yes</strong> ระบุว่าหาก ใช่คนเหล่านี้แล้วเราจะ <strong>เตะ</strong> เขาไปที่ไหน ซึ่งผมตั้งไว้เป็น null แปลว่าไม่เตะ อันที่จริง yes กับ no ก็ไม่ควรมีค่าในเวลาเดียวกันไม่งั้นหน้านี้ก็ไม่น่าจะมีคนเข้าได้</li>
</ol>

<p>เนื่องจาก roles เป็น array เราก็จะเช็คทีละสมาชิกของ roles หากเช็คแล้วไม่มีการ <strong>เตะ</strong> เกิดขึ้นก็จะไปเช็ค roles ตัวต่อไปเรื่อย ๆ จนกว่าจะครบ คนที่เข้าหน้านี้ได้ก็คือที่ไม่ถูกเตะเลย</p>

<p>ที่เหลือก็แค่เขียนโค้ดเพื่อบังคับใช้กฎเหล่านี้</p>

<h4 id="เขียนส่วนบังคับใช้กฎ-ในหน้า-appcoffee">เขียนส่วนบังคับใช้กฎ ในหน้า app.coffee</h4>
<p>ปกติผมใช้ app.coffee เป็นหน้าเร่ิมต้นของ project ซึ่งก็จะมี injector ต่าง ๆ มากมายในหน้านี้ แต่ตอนนี้เราจะสนใจแค่ส่วน <em>.run()</em> เท่านั้น ซึ่งจะเป็นส่วนที่เราจะเขียนตัวฟัง event <em>$stateChangeStart</em></p>

<p>ผมสมมติว่ามี method <em>userService.getRoles()</em> ซึ่งจะบอกว่าผู้ใช้เป็นใคร เช่น 001 คือเป็นคนธรรมดา หรือ 010 เป็น member ที่ login แล้ว</p>

<p>ผมจะพยายามเขียน comment ให้ละเอียดเพื่อจะได้อ่านแล้วเข้าใจได้ง่ายขึ้น</p>

<div class="language-coffeescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">angular</span><span class="p">.</span><span class="na">module</span> <span class="s">'app'</span><span class="p">,</span> <span class="p">[</span> <span class="p">...</span> <span class="na">many</span> <span class="nx">injectors</span> <span class="p">...]</span>
<span class="p">.</span><span class="na">run</span> <span class="p">[</span>
  <span class="s">'$rootScope'</span>
  <span class="s">'userService'</span>
  <span class="s">'USER_ROLES'</span>
  <span class="s">'$state'</span>
  <span class="p">(</span> <span class="nx">rootScope</span><span class="p">,</span>
    <span class="nx">userService</span><span class="p">,</span>
    <span class="nx">USER_ROLES</span><span class="p">,</span>
    <span class="nx">state</span> <span class="p">)</span> <span class="o">-&gt;</span>

    <span class="c1"># this var is needed to determine whether we should check </span>
    <span class="c1"># for the user's role or not</span>
    <span class="nx">intendedState</span> <span class="o">=</span> <span class="no">null</span>
    <span class="nx">rootScope</span><span class="p">.</span><span class="na">$on</span> <span class="s">'$stateChangeStart'</span><span class="p">,</span> <span class="p">(</span><span class="nx">event</span><span class="p">,</span> <span class="nx">next</span><span class="p">,</span> <span class="nx">current</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="c1"># the target route hasn't been specified its mode</span>
      <span class="c1"># so, anyone can get in</span>
      <span class="k">if</span> <span class="o">not</span> <span class="nx">next</span><span class="p">.</span><span class="na">data</span><span class="o">?</span> <span class="o">or</span> <span class="o">not</span> <span class="nx">next</span><span class="p">.</span><span class="na">data</span><span class="p">.</span><span class="na">roles</span><span class="o">?</span>
        <span class="c1"># update intendedState</span>
<span class="na">categories</span><span class="o">:</span> <span class="nx">dev</span>
        <span class="nx">intendedState</span> <span class="o">=</span> <span class="nx">next</span><span class="p">.</span><span class="na">name</span>
        <span class="k">return</span>

      <span class="c1"># the user is there!</span>
      <span class="c1"># because intendedState is where he's now going to</span>
      <span class="c1"># no permission checking this time (we've checked him last time)</span>
      <span class="k">if</span> <span class="nx">next</span><span class="p">.</span><span class="na">name</span> <span class="o">is</span> <span class="nx">intendedState</span>
        <span class="c1"># update intendedState</span>
<span class="na">categories</span><span class="o">:</span> <span class="nx">dev</span>
        <span class="nx">intendedState</span> <span class="o">=</span> <span class="nx">next</span><span class="p">.</span><span class="na">name</span>
        <span class="k">return</span>

      <span class="c1"># since, authorization takes time!</span>
      <span class="c1"># stop the page from normal redirection</span>
      <span class="c1"># because, we have to authorize the user first</span>
      <span class="nx">event</span><span class="p">.</span><span class="na">preventDefault</span><span class="p">()</span>

      <span class="c1"># get the user's role</span>
      <span class="c1"># we use callback function since `getRole` is not always fast</span>
      <span class="nx">userService</span><span class="p">.</span><span class="na">getRole</span> <span class="p">(</span><span class="nx">myRole</span><span class="p">)</span> <span class="o">-&gt;</span>
        <span class="c1"># get the target page's mode</span>
        <span class="nx">roles</span> <span class="o">=</span> <span class="nx">next</span><span class="p">.</span><span class="na">data</span><span class="p">.</span><span class="na">roles</span>

        <span class="nx">redirection</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># check user's role with each page's restriction</span>
        <span class="k">for</span> <span class="nx">each</span> <span class="k">in</span> <span class="nx">roles</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">each</span><span class="p">.</span><span class="na">authorized</span> <span class="o">&amp;</span> <span class="nx">myRole</span><span class="p">)</span> <span class="o">isnt</span> <span class="mi">0</span>
            <span class="c1"># the user is authorized</span>
            <span class="k">if</span> <span class="nx">each</span><span class="p">.</span><span class="na">yes</span><span class="o">?</span>
              <span class="c1"># follow the YES seciton, if exists</span>
              <span class="nx">redirection</span> <span class="o">=</span>
                <span class="na">target</span><span class="o">:</span> <span class="nx">each</span><span class="p">.</span><span class="na">yes</span>
              <span class="k">break</span>
          <span class="k">else</span>
            <span class="c1"># the user isn't authorized</span>
            <span class="k">if</span> <span class="nx">each</span><span class="p">.</span><span class="na">no</span><span class="o">?</span>
              <span class="c1"># follow the NO section, if exists</span>
              <span class="nx">redirection</span> <span class="o">=</span>
                <span class="na">target</span><span class="o">:</span> <span class="nx">each</span><span class="p">.</span><span class="na">no</span>
              <span class="k">break</span>

        <span class="k">if</span> <span class="o">not</span> <span class="nx">redirection</span><span class="p">.</span><span class="na">target</span><span class="o">?</span>
          <span class="c1"># the user is good, no need to kick him</span>
          <span class="c1"># redirect user to where he intended to go</span>
          <span class="c1"># according to 'next.name'</span>
          <span class="nx">intendedState</span> <span class="o">=</span> <span class="nx">next</span><span class="p">.</span><span class="na">name</span>
          <span class="c1"># attach 'current' parameters to the redirection</span>
          <span class="nx">state</span><span class="p">.</span><span class="na">go</span> <span class="nx">next</span><span class="p">.</span><span class="na">name</span><span class="p">,</span> <span class="nx">current</span>
        <span class="k">else</span>
          <span class="c1"># the user is not quailified, he has to be kicked somewhere</span>
          <span class="c1"># as described in 'redirection.target'</span>
          <span class="nx">intendedState</span> <span class="o">=</span> <span class="nx">redirection</span><span class="p">.</span><span class="na">target</span>
          <span class="c1"># attach 'current' parameters to the redirection</span>
          <span class="nx">state</span><span class="p">.</span><span class="na">go</span> <span class="nx">redirection</span><span class="p">.</span><span class="na">target</span><span class="p">,</span> <span class="nx">current</span>
<span class="p">]</span>
</code></pre></div></div>

<p>วิธีนี้ยังมีปัญหาอยู่ที่ต้องมีการ redirect ถึง 2 ครั้ง กว่าจะเข้าไปยังหน้าที่มีการกำหนด permission ไว้ได้ เพราะว่า redirect ครั้งแรกเราก็จะตรวจสอบสิทธิ์การเข้าหน้านั้นก่อนซึ่งอาจจะต้องใช้เวลา เนื่องจาก <em>userService.getRoles()</em> อาจจะไม่เร็วในบางกรณี เมื่อตรวจสอบเสร็จแล้วก็ต้อง redirect อีกครั้งเพื่อไปยังหน้าที่ต้องการจริง ๆ ปัญหาของตรงนี้อยู่ที่ว่า</p>

<ol>
  <li>เราไม่มีทางทำให้ <em>userService.getRoles()</em> เร็วเสมอต้นเสมอปลายได้ (ต่อให้มีการ cache ผลลัพธ์ไว้) เพราะว่าในกรณีแย่ ๆ เราก็ต้องเรียก http request ไปยัง server อยู่ดี</li>
  <li>เมื่อเราเรียก <em>event.preventDefault</em> แล้วแต่ไม่มี method สำหรับ resumeDefault ทำให้ต่อให้เราเช็คแล้วว่า user คนนี้เข้าหน้านี้ได้ แต่ก็ไม่สามารถให้เค้าเข้าไปต่อได้ (เนื่องจากเราหยุดกระบวนการไปแล้ว) เราต้องเริ่มกระบวนการใหม่อีกครั้งอยู่ดี</li>
</ol>

<p>อย่างไรก็ดีนี่เป็นวิธีที่ผมใช้จริง ๆ และแก้ปัญหาการกระพริบได้จริง ๆ แต่ผมก็ยังหวังว่าจะมีวิธีที่ดีกว่านี้ที่จะไม่ต้อง redirect ถึง 2 ครั้ง และหากมีใครแนะนำผมก็ยินดียิ่ง :D</p>


    <small>
      
      <a href="/tags/#angular">angular</a>
      
      <a href="/tags/#web">web</a>
      
    </small>
  </div><a class="u-url" href="/dev/2015/05/28/angularjs-routing-with-permissions-2.html" hidden></a>
</article>



      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col one-half">
      <h2 class="footer-heading">Konpat&#39;s Record of Struggles</h2>
        <ul class="contact-list">
          <li class="p-name">Konpat Preechakul</li><li><a class="u-email" href="mailto:the.akita.ta@gmail.com">the.akita.ta@gmail.com</a></li></ul>
      </div>

      <div class="footer-col one-half">
        <p>O thou, I long to rival thy greatest invention, the mind.</p>
      </div>

      <div class="social-links"><ul class="social-media-list"><li><a href="https://www.facebook.com/phizaz" title="phizaz"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#facebook"></use></svg></a></li><li><a href="https://github.com/phizaz" title="phizaz"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a href="https://www.instagram.com/phizaz" title="phizaz"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#instagram"></use></svg></a></li><li><a href="https://twitter.com/phizaz" title="phizaz"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg></a></li><li><a href="/feed.xml" title="rss"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#rss"></use></svg></a></li></ul>
</div>
    </div>

  </div>

</footer>
</body>

</html>
