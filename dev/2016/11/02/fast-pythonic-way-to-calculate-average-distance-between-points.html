<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Fast Pythonic Way to Calculate Average Distance Between Points | Konpat’s Record of Struggles</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Fast Pythonic Way to Calculate Average Distance Between Points" />
<meta name="author" content="Konpat Preechakul" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Finding an average distance between two sets of points (vectors) in a n-demensional euclidean space can be slow … harnessing O(a * b * n) of time complexity, where a and b denote the numbers of points in each set. A normal way to do this is something like: import numpy as np def dist(a, b): return np.linalg.norm(a - b) def dist_cluster_avg(points_A, points_B): from itertools import product s = sum(dist(a, b) for a, b in product(points_A, points_B)) return s / len(points_A) / len(points_B) Even though, the def dist(a, b) is arguable a very fast distance function, looping over each pair of points can be inexorably slow, to some extent because of the Python itself. There are so many ways out there to improve by the means of optimizations, it is important to note that the time complexity stays the same, but it is much better implemented. I found this, using cdist from scipy, and sum from numpy : def dist_cluster_avg_fast(points_A, points_B): from scipy.spatial.distance import cdist arr = cdist(points_A, points_B, metric=&#39;euclidean&#39;) return np.sum(arr) / (len(points_A) * len(points_B)) How much the gain ? You might ask, here it is. points_A = np.random.rand(500, 100) points_B = np.random.rand(500, 100) dist_cluster_avg(points_A, points_B) =&gt; 2.569478988647461 seconds dist_cluster_avg_fast(points_A, points_B) =&gt; 0.15470504760742188 seconds Much faster huh?" />
<meta property="og:description" content="Finding an average distance between two sets of points (vectors) in a n-demensional euclidean space can be slow … harnessing O(a * b * n) of time complexity, where a and b denote the numbers of points in each set. A normal way to do this is something like: import numpy as np def dist(a, b): return np.linalg.norm(a - b) def dist_cluster_avg(points_A, points_B): from itertools import product s = sum(dist(a, b) for a, b in product(points_A, points_B)) return s / len(points_A) / len(points_B) Even though, the def dist(a, b) is arguable a very fast distance function, looping over each pair of points can be inexorably slow, to some extent because of the Python itself. There are so many ways out there to improve by the means of optimizations, it is important to note that the time complexity stays the same, but it is much better implemented. I found this, using cdist from scipy, and sum from numpy : def dist_cluster_avg_fast(points_A, points_B): from scipy.spatial.distance import cdist arr = cdist(points_A, points_B, metric=&#39;euclidean&#39;) return np.sum(arr) / (len(points_A) * len(points_B)) How much the gain ? You might ask, here it is. points_A = np.random.rand(500, 100) points_B = np.random.rand(500, 100) dist_cluster_avg(points_A, points_B) =&gt; 2.569478988647461 seconds dist_cluster_avg_fast(points_A, points_B) =&gt; 0.15470504760742188 seconds Much faster huh?" />
<link rel="canonical" href="https://blog.konpat.me/dev/2016/11/02/fast-pythonic-way-to-calculate-average-distance-between-points.html" />
<meta property="og:url" content="https://blog.konpat.me/dev/2016/11/02/fast-pythonic-way-to-calculate-average-distance-between-points.html" />
<meta property="og:site_name" content="Konpat’s Record of Struggles" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-11-02T16:46:51+07:00" />
<script type="application/ld+json">
{"description":"Finding an average distance between two sets of points (vectors) in a n-demensional euclidean space can be slow … harnessing O(a * b * n) of time complexity, where a and b denote the numbers of points in each set. A normal way to do this is something like: import numpy as np def dist(a, b): return np.linalg.norm(a - b) def dist_cluster_avg(points_A, points_B): from itertools import product s = sum(dist(a, b) for a, b in product(points_A, points_B)) return s / len(points_A) / len(points_B) Even though, the def dist(a, b) is arguable a very fast distance function, looping over each pair of points can be inexorably slow, to some extent because of the Python itself. There are so many ways out there to improve by the means of optimizations, it is important to note that the time complexity stays the same, but it is much better implemented. I found this, using cdist from scipy, and sum from numpy : def dist_cluster_avg_fast(points_A, points_B): from scipy.spatial.distance import cdist arr = cdist(points_A, points_B, metric=&#39;euclidean&#39;) return np.sum(arr) / (len(points_A) * len(points_B)) How much the gain ? You might ask, here it is. points_A = np.random.rand(500, 100) points_B = np.random.rand(500, 100) dist_cluster_avg(points_A, points_B) =&gt; 2.569478988647461 seconds dist_cluster_avg_fast(points_A, points_B) =&gt; 0.15470504760742188 seconds Much faster huh?","author":{"@type":"Person","name":"Konpat Preechakul"},"@type":"BlogPosting","url":"https://blog.konpat.me/dev/2016/11/02/fast-pythonic-way-to-calculate-average-distance-between-points.html","headline":"Fast Pythonic Way to Calculate Average Distance Between Points","dateModified":"2016-11-02T16:46:51+07:00","datePublished":"2016-11-02T16:46:51+07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.konpat.me/dev/2016/11/02/fast-pythonic-way-to-calculate-average-distance-between-points.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://blog.konpat.me/feed.xml" title="Konpat's Record of Struggles" /><script async src="https://www.googletagmanager.com/gtag/js?id=UA-91416417-1"></script>
<script>
  window['ga-disable-UA-91416417-1'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-91416417-1');
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Konpat&#39;s Record of Struggles</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>
        
        <div class="trigger">
          <!--
            my_page.autogen is populated by the pagination logic for all pages
                            that are automatically created by the gem. Check for non-existence to exclude pagination pages from site.pages iterators
          -->
          
            
          
            
            <a class="page-link" href="/about/">About</a>
            
          
            
          
            
            <a class="page-link" href="/tags/">Tags</a>
            
          
            
          
            
          
            
            <a class="page-link" href="/all/index.html">All Posts</a>
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
            <a class="page-link" href="/dev/index.html">Development</a>
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
        </div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Fast Pythonic Way to Calculate Average Distance Between Points</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2016-11-02T16:46:51+07:00" itemprop="datePublished">Nov 2, 2016
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Finding an average distance between two sets of points (vectors) in a n-demensional euclidean space can be <strong>slow</strong> … harnessing <code class="highlighter-rouge">O(a * b * n)</code> of time complexity, where <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code> denote the numbers of points in each set.</p>

<p>A normal way to do this is something like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import numpy as np
def dist(a, b):
    return np.linalg.norm(a - b)

def dist_cluster_avg(points_A, points_B):
    from itertools import product
    s = sum(dist(a, b) for a, b in product(points_A, points_B))
    return s / len(points_A) / len(points_B)
</code></pre></div></div>

<p>Even though, the <code class="highlighter-rouge">def dist(a, b)</code> is arguable a very fast distance function, looping over each pair of points can be inexorably slow, to some extent because of the Python itself.</p>

<p>There are so many ways out there to improve by the means of optimizations, it is important to note that the time complexity stays the same, but it is much better implemented.</p>

<p>I found this, using <code class="highlighter-rouge">cdist</code> from <code class="highlighter-rouge">scipy</code>, and <code class="highlighter-rouge">sum</code> from <code class="highlighter-rouge">numpy</code> :</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def dist_cluster_avg_fast(points_A, points_B):
    from scipy.spatial.distance import cdist
    arr = cdist(points_A, points_B, metric='euclidean')
    return np.sum(arr) / (len(points_A) * len(points_B))
</code></pre></div></div>

<p>How much the gain ? You might ask, here it is.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>points_A = np.random.rand(500, 100)
points_B = np.random.rand(500, 100)

dist_cluster_avg(points_A, points_B) =&gt; 2.569478988647461 seconds
dist_cluster_avg_fast(points_A, points_B) =&gt; 0.15470504760742188 seconds
</code></pre></div></div>

<p>Much faster huh?</p>


    <small>
      
      <a href="/tags/#python">python</a>
      
    </small>
  </div><a class="u-url" href="/dev/2016/11/02/fast-pythonic-way-to-calculate-average-distance-between-points.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col one-half">
      <h2 class="footer-heading">Konpat&#39;s Record of Struggles</h2>
        <ul class="contact-list">
          <li class="p-name">Konpat Preechakul</li><li><a class="u-email" href="mailto:the.akita.ta@gmail.com">the.akita.ta@gmail.com</a></li></ul>
      </div>

      <div class="footer-col one-half">
        <p>O thou, I long to rival thy greatest invention, the mind.</p>
      </div>

      <div class="social-links"><ul class="social-media-list"><li><a href="https://www.facebook.com/phizaz" title="phizaz"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#facebook"></use></svg></a></li><li><a href="https://github.com/phizaz" title="phizaz"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a href="https://www.instagram.com/phizaz" title="phizaz"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#instagram"></use></svg></a></li><li><a href="https://twitter.com/phizaz" title="phizaz"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg></a></li><li><a href="/feed.xml" title="rss"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#rss"></use></svg></a></li></ul>
</div>
    </div>

  </div>

</footer>
</body>

</html>
